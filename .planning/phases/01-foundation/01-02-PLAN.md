---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Implement configuration system for Pleb with TOML parsing and validation.

Purpose: Enable users to configure which repo to watch, which labels trigger actions, and how to invoke Claude Code.
Output: Working config loading from `pleb.toml` with validation and CLI integration.
</objective>

<execution_context>
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@src/main.rs
@src/cli.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define config structure and TOML parsing</name>
  <files>src/config.rs, pleb.example.toml</files>
  <action>
    Create src/config.rs with serde-deserializable config structs:

    ```
    Config {
      github: GithubConfig {
        owner: String,           // repo owner
        repo: String,            // repo name
        token_env: String,       // env var name for GitHub token (default: "GITHUB_TOKEN")
      },
      labels: LabelConfig {
        ready: String,           // label that triggers processing (default: "pleb:ready")
        provisioning: String,    // label during setup (default: "pleb:provisioning")
        waiting: String,         // label when Claude needs input (default: "pleb:waiting")
        working: String,         // label when actively working (default: "pleb:working")
        done: String,            // label when complete (default: "pleb:done")
      },
      claude: ClaudeConfig {
        command: String,         // base command (default: "claude")
        args: Vec<String>,       // additional args (default: ["--dangerously-skip-permissions"])
        planning_mode: bool,     // start in planning mode (default: true)
      },
      paths: PathConfig {
        worktree_base: PathBuf,  // where to create worktrees (default: "./worktrees")
      },
    }
    ```

    Implement:
    - `Config::load(path: &Path) -> Result<Config>` - load and parse TOML file
    - `Config::load_default() -> Result<Config>` - load from ./pleb.toml
    - Use serde default attributes for optional fields

    Create pleb.example.toml with documented example configuration.

    Avoid: Don't use config crate or figment - plain toml + serde is simpler for this use case.
    Why: We have a single config file, no complex layering needed. Keep dependencies minimal.
  </action>
  <verify>
    - cargo build succeeds
    - Config struct compiles with all serde derives
    - pleb.example.toml is valid TOML
  </verify>
  <done>Config module compiles, example config file created</done>
</task>

<task type="auto">
  <name>Task 2: Config validation and CLI integration</name>
  <files>src/config.rs, src/main.rs, src/cli.rs</files>
  <action>
    Add validation to Config:
    - `Config::validate(&self) -> Result<()>` - check required fields, paths exist or can be created
    - Validate owner/repo are non-empty
    - Validate labels don't conflict with each other
    - Warn (via tracing) if worktree_base doesn't exist (will be created later)

    Add --config flag to CLI:
    - Global flag: `--config <PATH>` with default "pleb.toml"
    - Load config in main() before dispatching to subcommands
    - Pass config reference to subcommand handlers (update signatures)

    Update main.rs:
    - Load config first
    - Validate config
    - On error, print helpful message about creating pleb.toml from example
    - Pass validated config to subcommand dispatch

    Add `config` subcommand:
    - `pleb config show` - print current config (parsed and validated)
    - `pleb config init` - copy pleb.example.toml to pleb.toml if it doesn't exist

    Avoid: Don't silently ignore missing config file for `watch` command.
    Why: Config is required for watching - fail fast with clear error.
  </action>
  <verify>
    - `cargo run -- --help` shows --config flag
    - `cargo run -- config init` creates pleb.toml from example
    - `cargo run -- config show` displays parsed config
    - `cargo run -- watch` without config file shows helpful error
    - `cargo run -- watch` with valid config shows "Not yet implemented" (from plan 01-01)
  </verify>
  <done>Config loads and validates, CLI integrates config, helpful errors on missing/invalid config</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release` succeeds without errors or warnings
- [ ] `cargo clippy` passes
- [ ] pleb.example.toml documents all config options
- [ ] `pleb config init` creates working config file
- [ ] `pleb config show` displays loaded config
- [ ] Missing config produces helpful error message
- [ ] Invalid config produces specific validation error
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No compiler warnings
- Config system ready for use by subsequent phases
- Phase 1 complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`:

# Phase 1 Plan 2: Config System Summary

**[One-liner describing what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `src/config.rs` - Config structs and loading logic
- `src/main.rs` - Config integration
- `src/cli.rs` - --config flag and config subcommand
- `pleb.example.toml` - Example configuration

## Decisions Made
[Any decisions made during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Phase 1 complete. Ready for Phase 2: GitHub Integration.
</output>
