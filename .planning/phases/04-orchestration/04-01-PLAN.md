---
phase: 04-orchestration
plan: 01
type: execute
---

<objective>
Implement state machine for tracking active issues and their lifecycle states.

Purpose: Central state management that tracks which issues are being worked on and their current state, enabling the daemon to make decisions about what actions to take.
Output: `src/state.rs` with IssueTracker struct and state transition logic.
</objective>

<execution_context>
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@src/github.rs
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IssueTracker struct</name>
  <files>src/state.rs, src/main.rs</files>
  <action>
Create src/state.rs with:
- `TrackedIssue` struct containing: issue_number (u64), state (PlebState), worktree_path (Option<PathBuf>), started_at (Instant), last_updated (Instant)
- `IssueTracker` struct with: tracked: HashMap<u64, TrackedIssue>
- Methods: `new()`, `track(issue_number, state)`, `untrack(issue_number)`, `get(issue_number)`, `get_by_state(state) -> Vec<&TrackedIssue>`, `update_state(issue_number, new_state)`, `set_worktree_path(issue_number, path)`
- Use std::time::Instant for timestamps (monotonic, good for duration tracking)
- Move PlebState from github.rs to state.rs (it's more about state management than GitHub API)

Add `mod state;` to main.rs.
  </action>
  <verify>cargo build compiles without errors</verify>
  <done>IssueTracker struct exists with all specified methods, PlebState moved to state.rs</done>
</task>

<task type="auto">
  <name>Task 2: Add state transition validation</name>
  <files>src/state.rs</files>
  <action>
Add to state.rs:
- `PlebState::valid_transitions(&self) -> Vec<PlebState>` method that returns valid next states:
  - Ready -> [Provisioning]
  - Provisioning -> [Waiting, Working] (Waiting if needs user input before Claude starts)
  - Waiting -> [Working]
  - Working -> [Waiting, Done] (Waiting if Claude needs user input)
  - Done -> [] (terminal state)
- `IssueTracker::transition(issue_number, to_state) -> Result<()>` that validates the transition is allowed before updating
- Return error with helpful message if transition is invalid (e.g., "Cannot transition from Ready to Working directly, must go through Provisioning first")
- Add `is_terminal(&self) -> bool` method to PlebState (true only for Done)

Keep it simple - we're just validating transitions, not enforcing complex business logic.
  </action>
  <verify>cargo build compiles, cargo test (if tests exist) passes</verify>
  <done>State transitions are validated, invalid transitions return descriptive errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds without errors
- [ ] `cargo clippy` has no errors (warnings okay)
- [ ] IssueTracker can track, untrack, and query issues
- [ ] State transitions are validated (Ready->Working should fail)
- [ ] PlebState moved from github.rs to state.rs, github.rs imports from state
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No compiler errors or warnings that indicate problems
- State machine is ready for use by the daemon loop
</success_criteria>

<output>
After completion, create `.planning/phases/04-orchestration/04-01-SUMMARY.md`
</output>
