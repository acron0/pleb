---
phase: 04-orchestration
plan: 03
type: execute
---

<objective>
Implement Claude Code invocation within tmux windows.

Purpose: Spawn Claude Code in an issue's tmux window with the rendered prompt, and track whether Claude is currently running.
Output: `src/claude.rs` with ClaudeRunner struct for invoking and monitoring Claude processes.
</objective>

<execution_context>
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/04-orchestration/04-01-SUMMARY.md
@.planning/phases/04-orchestration/04-02-SUMMARY.md
@src/config.rs
@src/tmux.rs
@src/templates.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClaudeRunner struct</name>
  <files>src/claude.rs, src/main.rs</files>
  <action>
Create src/claude.rs with:
- `ClaudeRunner` struct containing: command (String), args (Vec<String>), tmux (TmuxManager reference or owned)
- `ClaudeRunner::new(config: &ClaudeConfig, tmux_config: &TmuxConfig) -> Self`
- `ClaudeRunner::invoke(&self, issue_number: u64, prompt: &str) -> Result<()>` that:
  1. Writes prompt to a temp file (avoids shell escaping issues with multiline prompts)
  2. Constructs claude command: `{command} {args...} --print < {temp_file}`
  3. Uses TmuxManager::send_keys() to run the command in the issue's window
  4. The temp file approach is cleaner than trying to escape the prompt for shell

Use --print flag so Claude outputs to the terminal (visible in tmux).
The temp file can be in /tmp/pleb-prompt-{issue_number}.md - it's okay if it persists.

Add `mod claude;` to main.rs.
  </action>
  <verify>cargo build compiles without errors</verify>
  <done>ClaudeRunner struct exists with invoke() method that sends claude command to tmux</done>
</task>

<task type="auto">
  <name>Task 2: Add process detection for Claude status</name>
  <files>src/claude.rs</files>
  <action>
Add to src/claude.rs:
- `ClaudeRunner::is_running(&self, issue_number: u64) -> Result<bool>` that checks if Claude is running in the window
  - Use `tmux list-panes -t {session}:{window} -F "#{pane_current_command}"` to get the running command
  - Check if output contains "claude" (case-insensitive)
  - Return false if window doesn't exist
- `ClaudeRunner::is_idle(&self, issue_number: u64) -> Result<bool>` that returns !is_running() - window exists but Claude not running (useful for detecting when Claude finished)

This is a simple heuristic - if the pane's current command is claude, it's running. When Claude exits, the shell prompt returns and pane_current_command will be "bash" or "zsh".

Note: This won't catch if Claude is blocked waiting for input, but that's okay - the label system (pleb:waiting) handles that via hooks in Phase 5.
  </action>
  <verify>cargo build compiles without errors</verify>
  <done>is_running() and is_idle() methods exist for detecting Claude process state</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds without errors
- [ ] `cargo clippy` has no errors
- [ ] ClaudeRunner can invoke Claude with a prompt in a tmux window
- [ ] Process detection can distinguish running vs idle windows
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Claude can be invoked in tmux windows
- Process state can be detected
</success_criteria>

<output>
After completion, create `.planning/phases/04-orchestration/04-03-SUMMARY.md`
</output>
