---
phase: 04-orchestration
plan: 04
type: execute
---

<objective>
Implement the main daemon loop that ties together GitHub watching, provisioning, and Claude invocation.

Purpose: The `pleb watch` command becomes a functioning daemon that polls for issues, provisions environments, invokes Claude, and manages state transitions.
Output: Fully working `watch` command in main.rs that orchestrates the complete issue lifecycle.
</objective>

<execution_context>
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/04-orchestration/04-01-SUMMARY.md
@.planning/phases/04-orchestration/04-02-SUMMARY.md
@.planning/phases/04-orchestration/04-03-SUMMARY.md
@src/main.rs
@src/config.rs
@src/github.rs
@src/state.rs
@src/templates.rs
@src/claude.rs
@src/worktree.rs
@src/tmux.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement watch command orchestration</name>
  <files>src/main.rs</files>
  <action>
Replace the placeholder `Commands::Watch` handler with full implementation:

Create an `Orchestrator` struct (can be in main.rs or new src/orchestrator.rs) with:
- github: GitHubClient
- worktree: WorktreeManager
- tmux: TmuxManager
- claude: ClaudeRunner
- templates: TemplateEngine
- tracker: IssueTracker
- config: Config (clone needed parts)

Implement `Orchestrator::run(&mut self) -> Result<()>`:
1. Verify GitHub connection
2. Ensure repo is cloned (worktree.ensure_repo())
3. Load the new_issue template
4. Enter polling loop with config.watch.poll_interval_secs:
   a. Fetch issues with pleb:ready label
   b. For each new issue not in tracker:
      - Log: "Processing issue #{number}: {title}"
      - Transition label: ready -> provisioning
      - Create worktree
      - Create tmux window
      - Render prompt with issue context
      - Invoke Claude
      - Transition label: provisioning -> working
      - Track issue in IssueTracker with Working state
   c. Sleep for poll_interval

Handle Ctrl+C gracefully with tokio::signal::ctrl_c() - log "Shutting down..." and exit cleanly.

Keep it simple for now - no cleanup of finished issues yet (that's for hooks in Phase 5).
  </action>
  <verify>cargo build compiles, `cargo run -- watch` starts and logs "Starting watch mode"</verify>
  <done>watch command runs a polling loop, provisions new issues, invokes Claude</done>
</task>

<task type="auto">
  <name>Task 2: Add error handling and resilience</name>
  <files>src/main.rs (or src/orchestrator.rs)</files>
  <action>
Improve the polling loop with:
- Per-issue error handling: if provisioning one issue fails, log error and continue with others (don't crash the daemon)
- Wrap issue processing in a function that returns Result, log errors with tracing::error!
- Skip issues that are already being tracked (avoid re-provisioning)
- Add startup banner: "Pleb daemon started - watching {owner}/{repo} for issues with label '{ready_label}'"
- Log each poll cycle at debug level: "Polling for new issues..."
- Log when no new issues found: "No new issues with {ready_label} label"

The daemon should be resilient:
- Network errors on one poll shouldn't crash it
- Individual issue failures shouldn't affect others
- Clear logging so user knows what's happening
  </action>
  <verify>cargo build compiles, daemon handles errors gracefully without crashing</verify>
  <done>Daemon is resilient to individual failures, has clear logging, handles Ctrl+C</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds without errors
- [ ] `cargo clippy` has no errors
- [ ] `cargo run -- watch` starts the daemon and shows startup banner
- [ ] Daemon polls GitHub at configured interval (check logs)
- [ ] Daemon provisions worktree + tmux window for issues with pleb:ready
- [ ] Daemon invokes Claude with rendered prompt
- [ ] Daemon transitions labels correctly (ready -> provisioning -> working)
- [ ] Ctrl+C shuts down gracefully
- [ ] Individual issue failures don't crash the daemon
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Phase 4 complete: Main orchestration loop is functional
- Ready for Phase 5 (hooks for state transitions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-orchestration/04-04-SUMMARY.md`
</output>
