---
phase: 02-github-integration
plan: 02
type: execute
---

<objective>
Implement issue fetching with label filtering and define issue data structures.

Purpose: Enable Pleb to discover issues ready for processing.
Output: Can fetch issues by label, with structured Issue type for downstream use.
</objective>

<execution_context>
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/02-github-integration/02-01-SUMMARY.md
@src/github.rs
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Issue data structure</name>
  <files>src/github.rs</files>
  <action>
    Add Issue struct to github.rs:

    ```rust
    #[derive(Debug, Clone)]
    pub struct Issue {
      pub number: u64,
      pub title: String,
      pub body: String,
      pub labels: Vec<String>,
      pub state: IssueState,
      pub html_url: String,
    }

    #[derive(Debug, Clone, PartialEq)]
    pub enum IssueState {
      Open,
      Closed,
    }
    ```

    Implement From<octocrab::models::issues::Issue> for Issue to convert from octocrab types.

    The body field should handle Option<String> from GitHub (empty body = empty string).

    Avoid: Don't store the full octocrab Issue - extract only what we need.
    Why: Cleaner API, easier to test, decoupled from octocrab types.
  </action>
  <verify>
    - cargo build succeeds
    - Issue struct compiles with all derives
  </verify>
  <done>Issue struct defined with conversion from octocrab types</done>
</task>

<task type="auto">
  <name>Task 2: Implement issue fetching by label</name>
  <files>src/github.rs</files>
  <action>
    Add methods to GitHubClient:

    ```rust
    impl GitHubClient {
      /// Fetch all open issues with the specified label
      pub async fn get_issues_with_label(&self, label: &str) -> Result<Vec<Issue>> {
        // Use octocrab to list issues
        // Filter by label and state=open
        // Convert to our Issue type
      }

      /// Fetch a single issue by number
      pub async fn get_issue(&self, number: u64) -> Result<Issue> {
        // Fetch specific issue
        // Convert to our Issue type
      }
    }
    ```

    Use octocrab's IssueHandler:
    - `self.client.issues(&self.owner, &self.repo).list()`
    - Apply label filter and state filter
    - Handle pagination if needed (for now, first page is fine - issues with pleb labels should be few)

    Avoid: Don't fetch all issues and filter in Rust - use GitHub's label filter.
    Why: More efficient, respects rate limits.
  </action>
  <verify>
    - cargo build succeeds
    - cargo clippy passes
  </verify>
  <done>Can fetch issues by label from GitHub API</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release` succeeds without errors
- [ ] `cargo clippy` passes
- [ ] Issue struct has all required fields
- [ ] get_issues_with_label method compiles
- [ ] get_issue method compiles
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No compiler warnings
- Issue fetching ready for use in orchestration
</success_criteria>

<output>
After completion, create `.planning/phases/02-github-integration/02-02-SUMMARY.md`:

# Phase 2 Plan 2: Issue Fetching Summary

**[One-liner describing what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `src/github.rs` - Issue struct and fetching methods

## Decisions Made
[Any decisions made during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 02-03-PLAN.md (Label Management)
</output>
