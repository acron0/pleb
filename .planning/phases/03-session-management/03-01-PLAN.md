---
phase: 03-session-management
plan: 01
type: execute
---

<objective>
Create git worktree management module for issue-based worktrees.

Purpose: Each issue gets its own worktree so Claude can work on multiple issues in parallel without branch conflicts.
Output: Worktree module that can create, remove, list, and locate worktrees for issues.
</objective>

<execution_context>
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/02-github-integration/02-03-SUMMARY.md
@src/config.rs
@src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worktree module with create functionality</name>
  <files>src/worktree.rs, src/main.rs</files>
  <action>
    Create src/worktree.rs with:

    ```rust
    pub struct WorktreeManager {
      repo_dir: PathBuf,      // where the main repo clone lives
      worktree_base: PathBuf, // where worktrees are created
    }

    impl WorktreeManager {
      pub fn new(config: &PathConfig) -> Self { ... }

      /// Create a worktree for an issue
      /// Creates branch `pleb/issue-{number}` and worktree at `worktree_base/issue-{number}`
      pub async fn create_worktree(&self, issue_number: u64) -> Result<PathBuf> {
        // 1. Check if worktree already exists, return path if so
        // 2. Create branch from main/master: git branch pleb/issue-{number}
        // 3. Create worktree: git worktree add {path} pleb/issue-{number}
        // 4. Return worktree path
      }

      /// Get the path to a worktree for an issue (if it exists)
      pub fn get_worktree_path(&self, issue_number: u64) -> Option<PathBuf> {
        let path = self.worktree_base.join(format!("issue-{}", issue_number));
        if path.exists() { Some(path) } else { None }
      }
    }
    ```

    Use tokio::process::Command for git operations.
    Add `mod worktree;` to main.rs.

    Avoid: Don't use libgit2/git2 crate - shell out to git command.
    Why: Simpler, git CLI is always available, worktree support in git2 is limited.
  </action>
  <verify>
    - cargo build succeeds
    - WorktreeManager struct compiles
    - create_worktree method compiles
  </verify>
  <done>Worktree module created with create functionality</done>
</task>

<task type="auto">
  <name>Task 2: Add worktree cleanup and listing</name>
  <files>src/worktree.rs</files>
  <action>
    Add methods to WorktreeManager:

    ```rust
    impl WorktreeManager {
      /// Remove a worktree for an issue
      pub async fn remove_worktree(&self, issue_number: u64) -> Result<()> {
        // 1. Get worktree path
        // 2. Run: git worktree remove {path} --force
        // 3. Optionally delete the branch: git branch -D pleb/issue-{number}
      }

      /// List all active issue worktrees
      pub async fn list_worktrees(&self) -> Result<Vec<u64>> {
        // 1. Run: git worktree list --porcelain
        // 2. Parse output for worktrees in worktree_base
        // 3. Extract issue numbers from paths (issue-123 -> 123)
        // 4. Return list of issue numbers
      }

      /// Check if repo_dir exists and is a git repo, clone if needed
      pub async fn ensure_repo(&self, owner: &str, repo: &str) -> Result<()> {
        // 1. If repo_dir exists and has .git, return Ok
        // 2. Otherwise, clone: git clone https://github.com/{owner}/{repo} {repo_dir}
        // Note: Uses HTTPS, user's git credentials handle auth
      }
    }
    ```

    Avoid: Don't try to parse git worktree list with regex on the human-readable format.
    Why: --porcelain format is stable and machine-parseable.
  </action>
  <verify>
    - cargo build succeeds
    - cargo clippy passes
    - All methods compile
  </verify>
  <done>Worktree cleanup and listing implemented</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release` succeeds without errors
- [ ] `cargo clippy` passes
- [ ] WorktreeManager has: new, create_worktree, get_worktree_path, remove_worktree, list_worktrees, ensure_repo
- [ ] All methods use tokio::process::Command for git operations
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No compiler warnings (except expected dead_code)
- Worktree management ready for orchestration
</success_criteria>

<output>
After completion, create `.planning/phases/03-session-management/03-01-SUMMARY.md`:

# Phase 3 Plan 1: Git Worktree Management Summary

**[One-liner describing what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `src/worktree.rs` - Worktree management module
- `src/main.rs` - Added module declaration

## Decisions Made
[Any decisions made during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 03-02-PLAN.md (Tmux Session Management)
</output>
