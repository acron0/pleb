---
phase: 03-session-management
plan: 02
type: execute
---

<objective>
Create tmux session management with single session and window-per-issue architecture.

Purpose: All issues run in windows within one tmux session, enabling easy tabbing through active work.
Output: Tmux module that manages one session with windows per issue, plus config for session name.
</objective>

<execution_context>
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/cache/taches-cc-resources/taches-cc-resources/1.0.0/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/03-session-management/03-01-SUMMARY.md
@src/config.rs
@src/main.rs
@pleb.example.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tmux config and create session/window module</name>
  <files>src/config.rs, src/tmux.rs, src/main.rs, pleb.example.toml</files>
  <action>
    Add TmuxConfig to config.rs:

    ```rust
    #[derive(Debug, Clone, Deserialize, Serialize)]
    pub struct TmuxConfig {
      #[serde(default = "default_session_name")]
      pub session_name: String,  // default: "pleb"
    }

    fn default_session_name() -> String {
      "pleb".to_string()
    }
    ```

    Add `tmux: TmuxConfig` to main Config struct.
    Update pleb.example.toml with [tmux] section.

    Create src/tmux.rs:

    ```rust
    pub struct TmuxManager {
      session_name: String,
    }

    impl TmuxManager {
      pub fn new(config: &TmuxConfig) -> Self { ... }

      /// Ensure the pleb session exists, create if not
      pub async fn ensure_session(&self) -> Result<()> {
        // Check: tmux has-session -t {session_name}
        // If not exists: tmux new-session -d -s {session_name}
      }

      /// Create a new window for an issue in the pleb session
      /// Window name: "issue-{number}"
      /// Working directory: the worktree path
      pub async fn create_window(&self, issue_number: u64, working_dir: &Path) -> Result<()> {
        // 1. Ensure session exists
        // 2. Check if window already exists
        // 3. Create window: tmux new-window -t {session_name} -n "issue-{number}" -c {working_dir}
      }

      /// Check if a window exists for an issue
      pub async fn window_exists(&self, issue_number: u64) -> Result<bool> {
        // tmux list-windows -t {session_name} -F '#{window_name}'
        // Check if "issue-{number}" is in the list
      }
    }
    ```

    Add `mod tmux;` to main.rs.

    Use tokio::process::Command for tmux operations.
  </action>
  <verify>
    - cargo build succeeds
    - TmuxConfig added to config
    - TmuxManager struct compiles
    - pleb.example.toml has [tmux] section
  </verify>
  <done>Tmux config and basic session/window creation implemented</done>
</task>

<task type="auto">
  <name>Task 2: Add window operations and session attachment</name>
  <files>src/tmux.rs, src/cli.rs, src/main.rs</files>
  <action>
    Add methods to TmuxManager:

    ```rust
    impl TmuxManager {
      /// List all issue windows in the session
      pub async fn list_windows(&self) -> Result<Vec<u64>> {
        // tmux list-windows -t {session_name} -F '#{window_name}'
        // Parse "issue-{number}" and extract numbers
      }

      /// Kill a window for an issue
      pub async fn kill_window(&self, issue_number: u64) -> Result<()> {
        // tmux kill-window -t {session_name}:issue-{number}
      }

      /// Send keys to a window (for starting Claude, etc.)
      pub async fn send_keys(&self, issue_number: u64, keys: &str) -> Result<()> {
        // tmux send-keys -t {session_name}:issue-{number} "{keys}" Enter
      }

      /// Attach to the pleb session (blocking - replaces current terminal)
      pub fn attach_command(&self) -> std::process::Command {
        // Returns Command for: tmux attach -t {session_name}
        // Caller can .exec() or .status() this
      }
    }
    ```

    Update CLI to implement the `attach` subcommand:
    - Load config
    - Create TmuxManager
    - Run attach_command (this replaces the pleb process with tmux)

    Update `list` subcommand to show active issue windows.

    Avoid: Don't try to attach from within an async context.
    Why: Attaching replaces the process, use std::process::Command and exec/status.
  </action>
  <verify>
    - cargo build succeeds
    - cargo clippy passes
    - `pleb attach` compiles (actual attachment requires tmux session)
    - `pleb list` compiles
  </verify>
  <done>Window operations and CLI attachment implemented, Phase 3 complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release` succeeds without errors
- [ ] `cargo clippy` passes
- [ ] TmuxManager has: ensure_session, create_window, window_exists, list_windows, kill_window, send_keys, attach_command
- [ ] CLI `attach` subcommand uses attach_command
- [ ] CLI `list` subcommand shows issue windows
- [ ] pleb.example.toml documents [tmux] section
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No compiler warnings (except expected dead_code)
- Phase 3 complete
- Session management ready for orchestration
</success_criteria>

<output>
After completion, create `.planning/phases/03-session-management/03-02-SUMMARY.md`:

# Phase 3 Plan 2: Tmux Session Management Summary

**[One-liner describing what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `src/config.rs` - Added TmuxConfig
- `src/tmux.rs` - Tmux session/window management
- `src/cli.rs` - Updated attach and list commands
- `src/main.rs` - Added module declaration, wired up commands
- `pleb.example.toml` - Added [tmux] section

## Decisions Made
[Any decisions made during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Phase 3 complete. Ready for Phase 4: Orchestration.
</output>
